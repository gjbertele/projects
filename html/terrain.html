<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <style>
        body{
            position:absolute;
            margin:0;
            width:100%;
            height:100%;
            overflow:hidden;
        }
        canvas{
            position:absolute;
            left:0;
            top:0;
        }
    </style>
    <canvas></canvas>
    <script>
        const canvas = document.querySelector('canvas')
        const ctx = canvas.getContext('2d',{alpha:false})
        const w = document.body.clientWidth;
        const h = document.body.clientHeight;
        const facesCube = [[[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]], [[-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]], [[-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1]], [[-1, -1, 1], [-1, -1, -1], [-1, 1, -1], [-1, 1, 1]], [[1, -1, 1], [1, -1, -1], [1, 1, -1], [1, 1, 1]], [[-1, 1, 1], [1, 1, 1], [1, 1, -1], [-1, 1, -1]]]
        const facesSquare = [[[1,0,1],[1,0,-1],[-1,0,-1],[-1,0,1]]]
        let worldWidth = 25
        let worldHeight = 35
        let boundaryPanning = 500
        let terrainDetail = 50
        canvas.width = w;
        canvas.height = h;
        let shapes = []
        let fov = w*0.9
        let keysdown = []
        let riverWidth = 25;
        let riverDepth = 4;
        const airDrag = 0.7
        let mousedown = false;
        let terrainDetailHalf = terrainDetail/2
        let mx = 0;
        let my = 0;
        let lmx = 0;
        let lmy = 0;
        let rockCount = 5;
        let baseShapes = []
        let cameraPos = {
            x:-1210,
            y:-938,
            z:-1095,
            rx:465,
            ry:0,
            rposX:0,
            rposZ:0,
        }
        let heightMounds = []
        let worldHillSpread = 300
        let sinArray = [0,0.01745240643728351,0.03489949670250097,0.05233595624294383,0.0697564737441253,0.08715574274765817,0.10452846326765346,0.12186934340514748,0.13917310096006544,0.15643446504023087,0.17364817766693033,0.1908089953765448,0.20791169081775931,0.224951054343865,0.24192189559966773,0.25881904510252074,0.27563735581699916,0.29237170472273677,0.3090169943749474,0.32556815445715664,0.3420201433256687,0.35836794954530027,0.374606593415912,0.3907311284892737,0.40673664307580015,0.42261826174069944,0.4383711467890774,0.45399049973954675,0.4694715627858908,0.48480962024633706,0.49999999999999994,0.5150380749100542,0.5299192642332049,0.5446390350150271,0.5591929034707469,0.573576436351046,0.5877852522924731,0.6018150231520483,0.6156614753256582,0.6293203910498374,0.6427876096865393,0.6560590289905072,0.6691306063588582,0.6819983600624985,0.6946583704589973,0.7071067811865475,0.7193398003386511,0.7313537016191705,0.7431448254773942,0.754709580222772,0.766044443118978,0.7771459614569708,0.788010753606722,0.7986355100472928,0.8090169943749475,0.8191520442889918,0.8290375725550417,0.8386705679454239,0.848048096156426,0.8571673007021122,0.8660254037844386,0.8746197071393957,0.8829475928589269,0.8910065241883678,0.898794046299167,0.9063077870366499,0.9135454576426009,0.9205048534524403,0.9271838545667874,0.9335804264972017,0.9396926207859083,0.9455185755993167,0.9510565162951535,0.9563047559630354,0.9612616959383189,0.9659258262890683,0.9702957262759965,0.9743700647852352,0.9781476007338056,0.981627183447664,0.984807753012208,0.9876883405951378,0.9902680687415703,0.992546151641322,0.9945218953682733,0.9961946980917455,0.9975640502598242,0.9986295347545738,0.9993908270190958,0.9998476951563913,1,0.9998476951563913,0.9993908270190958,0.9986295347545738,0.9975640502598242,0.9961946980917455,0.9945218953682734,0.9925461516413221,0.9902680687415704,0.9876883405951377,0.984807753012208,0.981627183447664,0.9781476007338057,0.9743700647852352,0.9702957262759965,0.9659258262890683,0.9612616959383189,0.9563047559630355,0.9510565162951536,0.9455185755993168,0.9396926207859084,0.9335804264972017,0.9271838545667874,0.9205048534524404,0.913545457642601,0.90630778703665,0.8987940462991669,0.8910065241883679,0.8829475928589271,0.8746197071393959,0.8660254037844387,0.8571673007021123,0.8480480961564261,0.8386705679454239,0.8290375725550417,0.819152044288992,0.8090169943749475,0.7986355100472927,0.788010753606722,0.777145961456971,0.766044443118978,0.7547095802227718,0.7431448254773942,0.7313537016191706,0.7193398003386514,0.7071067811865476,0.6946583704589971,0.6819983600624986,0.6691306063588583,0.6560590289905073,0.6427876096865395,0.6293203910498377,0.6156614753256584,0.6018150231520482,0.5877852522924732,0.5735764363510464,0.5591929034707469,0.544639035015027,0.5299192642332049,0.5150380749100544,0.49999999999999994,0.48480962024633717,0.4694715627858911,0.45399049973954686,0.4383711467890773,0.4226182617406995,0.40673664307580043,0.39073112848927416,0.37460659341591224,0.3583679495453002,0.3420201433256689,0.32556815445715703,0.3090169943749475,0.29237170472273705,0.27563735581699966,0.258819045102521,0.24192189559966773,0.22495105434386478,0.20791169081775931,0.19080899537654497,0.17364817766693028,0.15643446504023098,0.13917310096006574,0.12186934340514755,0.10452846326765373,0.08715574274765864,0.06975647374412552,0.05233595624294381,0.0348994967025007,0.01745240643728344,1.2246467991473532e-16,-0.017452406437283192,-0.0348994967025009,-0.052335956242943564,-0.06975647374412483,-0.08715574274765794,-0.10452846326765305,-0.12186934340514774,-0.13917310096006552,-0.15643446504023073,-0.17364817766693047,-0.19080899537654472,-0.20791169081775907,-0.22495105434386498,-0.2419218955996675,-0.25881904510252035,-0.275637355816999,-0.2923717047227364,-0.30901699437494773,-0.32556815445715676,-0.34202014332566866,-0.35836794954530043,-0.374606593415912,-0.39073112848927355,-0.4067366430757998,-0.4226182617406993,-0.43837114678907707,-0.45399049973954625,-0.46947156278589086,-0.48480962024633695,-0.5000000000000001,-0.5150380749100542,-0.5299192642332048,-0.5446390350150271,-0.5591929034707467,-0.5735764363510458,-0.587785252292473,-0.601815023152048,-0.6156614753256578,-0.6293203910498376,-0.6427876096865393,-0.6560590289905074,-0.6691306063588582,-0.6819983600624984,-0.6946583704589974,-0.7071067811865475,-0.7193398003386509,-0.7313537016191701,-0.743144825477394,-0.7547095802227717,-0.7660444431189779,-0.7771459614569711,-0.7880107536067221,-0.7986355100472928,-0.8090169943749473,-0.8191520442889916,-0.8290375725550414,-0.838670567945424,-0.848048096156426,-0.8571673007021121,-0.8660254037844384,-0.874619707139396,-0.882947592858927,-0.8910065241883678,-0.8987940462991668,-0.9063077870366497,-0.913545457642601,-0.9205048534524403,-0.9271838545667873,-0.9335804264972016,-0.9396926207859082,-0.9455185755993168,-0.9510565162951535,-0.9563047559630353,-0.961261695938319,-0.9659258262890683,-0.9702957262759965,-0.9743700647852351,-0.9781476007338056,-0.9816271834476639,-0.984807753012208,-0.9876883405951377,-0.9902680687415704,-0.9925461516413221,-0.9945218953682734,-0.9961946980917455,-0.9975640502598242,-0.9986295347545738,-0.9993908270190957,-0.9998476951563913,-1,-0.9998476951563913,-0.9993908270190958,-0.9986295347545738,-0.9975640502598243,-0.9961946980917455,-0.9945218953682734,-0.992546151641322,-0.9902680687415704,-0.9876883405951378,-0.9848077530122081,-0.9816271834476641,-0.9781476007338058,-0.9743700647852352,-0.9702957262759966,-0.9659258262890682,-0.9612616959383188,-0.9563047559630354,-0.9510565162951536,-0.945518575599317,-0.9396926207859085,-0.9335804264972021,-0.9271838545667874,-0.9205048534524405,-0.9135454576426008,-0.9063077870366499,-0.898794046299167,-0.8910065241883679,-0.8829475928589271,-0.8746197071393961,-0.8660254037844386,-0.8571673007021123,-0.8480480961564262,-0.8386705679454243,-0.8290375725550421,-0.8191520442889918,-0.8090169943749476,-0.798635510047293,-0.7880107536067218,-0.7771459614569708,-0.7660444431189781,-0.7547095802227722,-0.7431448254773946,-0.731353701619171,-0.7193398003386517,-0.7071067811865477,-0.6946583704589976,-0.6819983600624983,-0.6691306063588581,-0.6560590289905074,-0.6427876096865396,-0.6293203910498378,-0.6156614753256588,-0.6018150231520483,-0.5877852522924734,-0.5735764363510465,-0.5591929034707473,-0.544639035015027,-0.5299192642332058,-0.5150380749100545,-0.5000000000000004,-0.4848096202463369,-0.4694715627858908,-0.45399049973954697,-0.438371146789077,-0.4226182617407,-0.40673664307580015,-0.3907311284892747,-0.37460659341591235,-0.35836794954530077,-0.3420201433256686,-0.32556815445715753,-0.3090169943749477,-0.29237170472273627,-0.2756373558169998,-0.2588190451025207,-0.24192189559966787,-0.22495105434386534,-0.20791169081775987,-0.19080899537654467,-0.17364817766693127,-0.15643446504023112,-0.13917310096006588,-0.12186934340514811,-0.10452846326765342,-0.08715574274765832,-0.06975647374412476,-0.05233595624294437,-0.034899496702500823,-0.01745240643728445,-2.4492935982947064e-16]
        let cosArray = [1,0.9998476951563913,0.9993908270190958,0.9986295347545738,0.9975640502598242,0.9961946980917455,0.9945218953682733,0.992546151641322,0.9902680687415704,0.9876883405951378,0.984807753012208,0.981627183447664,0.9781476007338057,0.9743700647852352,0.9702957262759965,0.9659258262890683,0.9612616959383189,0.9563047559630354,0.9510565162951535,0.9455185755993168,0.9396926207859084,0.9335804264972017,0.9271838545667874,0.9205048534524404,0.9135454576426009,0.9063077870366499,0.898794046299167,0.8910065241883679,0.882947592858927,0.8746197071393957,0.8660254037844387,0.8571673007021123,0.848048096156426,0.838670567945424,0.8290375725550416,0.8191520442889918,0.8090169943749475,0.7986355100472928,0.788010753606722,0.7771459614569709,0.766044443118978,0.7547095802227721,0.7431448254773942,0.7313537016191706,0.7193398003386512,0.7071067811865476,0.6946583704589974,0.6819983600624985,0.6691306063588582,0.6560590289905073,0.6427876096865394,0.6293203910498375,0.6156614753256583,0.6018150231520484,0.5877852522924731,0.5735764363510462,0.5591929034707468,0.5446390350150272,0.5299192642332049,0.5150380749100544,0.5000000000000001,0.4848096202463371,0.46947156278589086,0.4539904997395468,0.43837114678907746,0.42261826174069944,0.4067366430758002,0.39073112848927394,0.37460659341591196,0.3583679495453004,0.3420201433256688,0.32556815445715676,0.30901699437494745,0.29237170472273677,0.27563735581699916,0.25881904510252074,0.2419218955996679,0.22495105434386492,0.20791169081775945,0.19080899537654492,0.17364817766693041,0.15643446504023092,0.1391731009600657,0.12186934340514749,0.10452846326765346,0.08715574274765814,0.06975647374412546,0.052335956242943966,0.03489949670250108,0.017452406437283376,6.123233995736766e-17,-0.017452406437283477,-0.03489949670250073,-0.05233595624294362,-0.06975647374412533,-0.08715574274765824,-0.10452846326765333,-0.12186934340514737,-0.13917310096006535,-0.15643446504023104,-0.1736481776669303,-0.1908089953765448,-0.20791169081775912,-0.2249510543438648,-0.24192189559966779,-0.25881904510252085,-0.27563735581699905,-0.29237170472273666,-0.30901699437494734,-0.3255681544571564,-0.3420201433256687,-0.35836794954530027,-0.37460659341591207,-0.3907311284892736,-0.40673664307580004,-0.42261826174069933,-0.4383711467890775,-0.4539904997395467,-0.46947156278589053,-0.484809620246337,-0.4999999999999998,-0.5150380749100543,-0.5299192642332048,-0.5446390350150271,-0.5591929034707467,-0.5735764363510458,-0.587785252292473,-0.6018150231520484,-0.6156614753256583,-0.6293203910498373,-0.6427876096865394,-0.6560590289905075,-0.6691306063588582,-0.6819983600624984,-0.694658370458997,-0.7071067811865475,-0.7193398003386512,-0.7313537016191705,-0.743144825477394,-0.754709580222772,-0.7660444431189779,-0.7771459614569707,-0.7880107536067219,-0.7986355100472929,-0.8090169943749473,-0.8191520442889916,-0.8290375725550416,-0.8386705679454242,-0.848048096156426,-0.8571673007021122,-0.8660254037844387,-0.8746197071393957,-0.8829475928589268,-0.8910065241883678,-0.898794046299167,-0.9063077870366499,-0.9135454576426008,-0.9205048534524402,-0.9271838545667873,-0.9335804264972017,-0.9396926207859083,-0.9455185755993167,-0.9510565162951535,-0.9563047559630354,-0.9612616959383187,-0.9659258262890682,-0.9702957262759965,-0.9743700647852352,-0.9781476007338057,-0.981627183447664,-0.984807753012208,-0.9876883405951377,-0.9902680687415703,-0.992546151641322,-0.9945218953682733,-0.9961946980917455,-0.9975640502598242,-0.9986295347545738,-0.9993908270190958,-0.9998476951563913,-1,-0.9998476951563913,-0.9993908270190958,-0.9986295347545738,-0.9975640502598243,-0.9961946980917455,-0.9945218953682734,-0.992546151641322,-0.9902680687415703,-0.9876883405951378,-0.984807753012208,-0.981627183447664,-0.9781476007338057,-0.9743700647852352,-0.9702957262759965,-0.9659258262890684,-0.9612616959383189,-0.9563047559630355,-0.9510565162951535,-0.9455185755993167,-0.9396926207859084,-0.9335804264972017,-0.9271838545667874,-0.9205048534524404,-0.9135454576426011,-0.90630778703665,-0.8987940462991671,-0.8910065241883681,-0.8829475928589269,-0.8746197071393959,-0.8660254037844386,-0.8571673007021123,-0.8480480961564261,-0.838670567945424,-0.8290375725550418,-0.819152044288992,-0.8090169943749476,-0.798635510047293,-0.7880107536067222,-0.7771459614569708,-0.766044443118978,-0.7547095802227719,-0.7431448254773942,-0.7313537016191706,-0.7193398003386511,-0.7071067811865477,-0.6946583704589976,-0.6819983600624989,-0.6691306063588585,-0.6560590289905076,-0.6427876096865395,-0.6293203910498372,-0.6156614753256581,-0.6018150231520483,-0.5877852522924732,-0.5735764363510464,-0.5591929034707472,-0.544639035015027,-0.529919264233205,-0.5150380749100545,-0.5000000000000004,-0.48480962024633684,-0.46947156278589075,-0.4539904997395469,-0.43837114678907774,-0.42261826174069994,-0.4067366430758001,-0.3907311284892738,-0.3746065934159123,-0.3583679495453007,-0.3420201433256694,-0.32556815445715664,-0.30901699437494756,-0.2923717047227371,-0.2756373558169989,-0.25881904510252063,-0.24192189559966779,-0.22495105434386525,-0.2079116908177598,-0.19080899537654547,-0.17364817766693033,-0.15643446504023104,-0.13917310096006494,-0.12186934340514717,-0.10452846326765336,-0.08715574274765825,-0.06975647374412558,-0.052335956242944306,-0.03489949670250165,-0.017452406437283498,-1.8369701987210297e-16,0.01745240643728313,0.03489949670250128,0.052335956242943946,0.06975647374412522,0.08715574274765789,0.10452846326765299,0.12186934340514768,0.13917310096006547,0.15643446504023067,0.17364817766692997,0.19080899537654425,0.20791169081775857,0.22495105434386492,0.24192189559966745,0.25881904510252113,0.2756373558169994,0.2923717047227367,0.30901699437494723,0.3255681544571563,0.34202014332566816,0.35836794954529955,0.37460659341591196,0.3907311284892735,0.40673664307580054,0.4226182617406996,0.4383711467890774,0.45399049973954664,0.4694715627858904,0.4848096202463365,0.5000000000000001,0.5150380749100542,0.5299192642332047,0.5446390350150266,0.5591929034707462,0.573576436351046,0.5877852522924729,0.6018150231520479,0.6156614753256585,0.6293203910498375,0.6427876096865393,0.656059028990507,0.6691306063588578,0.681998360062498,0.6946583704589966,0.7071067811865474,0.7193398003386509,0.7313537016191707,0.7431448254773942,0.7547095802227719,0.7660444431189778,0.7771459614569706,0.7880107536067216,0.7986355100472928,0.8090169943749473,0.8191520442889916,0.8290375725550414,0.838670567945424,0.8480480961564254,0.8571673007021121,0.8660254037844384,0.8746197071393959,0.8829475928589269,0.8910065241883678,0.8987940462991671,0.9063077870366497,0.913545457642601,0.9205048534524399,0.9271838545667873,0.9335804264972015,0.9396926207859084,0.9455185755993165,0.9510565162951535,0.9563047559630357,0.9612616959383187,0.9659258262890683,0.9702957262759965,0.9743700647852351,0.9781476007338056,0.981627183447664,0.9848077530122079,0.9876883405951377,0.9902680687415703,0.992546151641322,0.9945218953682733,0.9961946980917455,0.9975640502598243,0.9986295347545738,0.9993908270190958,0.9998476951563913,1]
        
        let y1 = (worldWidth-10)*Math.random()>>0
        let y2 = (worldWidth-10)*Math.random()>>0
        let riverSlope = (y2-y1)/worldHeight
        let riverDips = []
        let heightMap = []
        let riverSin = Math.random()*2-1
        //OPTIMIZATION CONSTANTS
        const wwtdh = worldWidth*terrainDetail/2
        const whtdh = worldHeight*terrainDetail/2
        const MPDR = Math.PI/180
        const fovInv = 1/fov

        function sin(ang){
            return sinArray[(ang + 360) % 360]
        }
        function cos(ang){
            return cosArray[(ang + 360) % 360]
        }
        function flatten(array){
    for (var i = 0; i < array.length; i++) {
        if(array[i] instanceof Array){
            array.splice.apply(array,[i,1].concat(array[i]));
            i--;
        }
    };
    return array;
}
        const isPointInPolygon = (latitude, longitude, polygon) => {

let x = latitude; let y = longitude

let inside = false
for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i][0]; const yi = polygon[i][1]
    const xj = polygon[j][0]; const yj = polygon[j][1]

    const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
    if (intersect) inside = !inside
}

return inside
};
function chunkCalc(x,z){
    return 1e6*((x/(4*terrainDetail))>>0) + (z/(4*terrainDetail)) >> 0
}
        function lookArraysUpdate(){
                    xAxis.x = Math.fround(Math.cos(cameraPos.rx*MPDR));
                    xAxis.y = Math.fround(Math.sin(cameraPos.rx*MPDR));

                    yAxis.x = -xAxis.y//Math.cos(cameraPos.rx*Math.PI/180 + Math.PI/2);
                    yAxis.y = xAxis.x//Math.sin(cameraPos.rx*Math.PI/180 + Math.PI/2);
                    

                    cameraPos.rposZ = cameraPos.z + (cameraPos.x-terrainDetailHalf*worldWidth)*xAxis.x+(cameraPos.z-terrainDetailHalf*worldHeight)*yAxis.x
                    cameraPos.rposX = cameraPos.x + (cameraPos.x-terrainDetailHalf*worldWidth)*xAxis.y+(cameraPos.z-terrainDetailHalf*worldHeight)*yAxis.y
        }
        function weightedRandom(min, max) {
  return Math.round(max / (Math.random() * max + min));
}
function terrainAtPoint(x,z){
    let modx = (x/terrainDetail)>>0
    let modz = (z/terrainDetail)>>0
    return heightMap[modx+modz*worldHeight]
}

function colorMap(i){
    let col = i.color.split('rgb(')[0].slice(0,-1).split(',')
    return 100**2 * col[0] + 100 * col[1] + col[0]
}

        for(let i = 0; i<worldHillSpread; i++){
            //heightMounds.push({x:worldWidth-weightedRandom(0,worldWidth),y:worldHeight-weightedRandom(0,worldHeight)})
            heightMounds.push({x:worldWidth-weightedRandom(1,worldWidth)>>0,y:Math.random()*worldHeight>>0})
            //heightMounds.push({x:Math.random()*worldWidth>>0,y:Math.random()*worldHeight>>0})
        }
        document.body.onmousedown = function(e){
            mousedown = true;
        }
        document.body.onmousemove = function(e){
            lmx = mx
            lmy = my
            mx = e.clientX;
            my = e.clientY;
        }
        document.body.onmouseup = function(e){
            mousedown = false
        }
        document.body.onkeydown = function(e){
            if(!keysdown.includes(e.key)) { keysdown.push(e.key) }
        }
        document.body.onkeyup = function(e){
            keysdown = keysdown.filter(i => i!=e.key)
        }
    



        let xAxis = {x:1,y:0}
        let yAxis = {x:0,y:1}

        const projectTo3D = (x, y, z) => {
            let ix = x - wwtdh
            let iy = y - cameraPos.y
            let iz = z - whtdh
            let rotatedX = ix*xAxis.x+iz*yAxis.x - cameraPos.x
            let rotatedZ = ix*xAxis.y+iz*yAxis.y - cameraPos.z
            var size = rotatedZ*fovInv + 1
            var xp = (rotatedX / size);
            var yp = (iy / size);
            let objectReturn = {
                x: xp>>0,
                y: yp>>0 
            }
            return objectReturn
        }
        const shapeFromPoint = (x, y) => {
            var answer = {
                x:1e6,
                y:1e6,
                z:1e6
            }
            shapes.forEach(function (i, v) {
                if(i.type == 0 || i.type == 2){
                i.screenBBoxes.forEach(function (k, t) {
                    if (isPointInPolygon(x, y, k.map(i => i = [i.x, i.y])) == true && cDist(i) < cDist(answer)) {
                        answer = i
                    }
                })
            }
            })
            return answer
        }
        const cDist = (i) => {
            return (i.x - cameraPos.rposX + cameraPos.x+ 350)**2 + (i.y - cameraPos.y)**2 + (i.z - cameraPos.rposZ + cameraPos.z - 250)**2
        }
        //OBJECT TYPES
        class Sphere {
            constructor(x,y,z,r) {
                let newObject = {
                    x,
                    y,
                    z,
                    transparency:1,
                    vx:0,
                    vy:0,
                    vz:0,
                    radius:r,
                    color:'rgb('+Math.floor(Math.random()*255)+','+Math.floor(Math.random()*255)+','+Math.floor(Math.random()*255)+')',
                    elasticity:0.9,
                    weight:100,
                    chunk:chunkCalc(x,z),
                    type:1,
                    draw:function(){
                        let i = this;
                        let nr = i.radius*terrainDetail**2/Math.sqrt(cDist(i))
                        return nr
                    }
                }
                shapes.push(newObject)
                return newObject
            }
        }
        class Cube {
            constructor(x,y,z,w,h,d) {
                let newObject = {
                    x,
                    y,
                    z,
                    width:w,
                    height:h,
                    depth:d,
                    faces:facesCube,
                    color:'rgb('+Math.floor(Math.random()*255)+','+Math.floor(Math.random()*255)+','+Math.floor(Math.random()*255)+')',
                    type:2,
                    transparency:1,
                    chunk:chunkCalc(x,z),
                    screenBBoxes:[],
                    draw: function(){
                        let i = this
                    var pts = []
                    facesCube.reverse().forEach(function (kt, tv) {
                        var tpts = []
                        kt.forEach(function (k, t) {
                            var p1x = i.x + (terrainDetail* 0.5 * k[0]) //- cameraPos.x
                            var p1y = i.y + (terrainDetail* 0.5 * k[1]) //- cameraPos.y
                            var p1z = i.z + (terrainDetail * 0.5 * k[2]) //- cameraPos.z
                            var p1 = projectTo3D(p1x, p1y, p1z)
                            tpts.push(p1)
                        })
                        pts.push(tpts)
                    })
                    i.screenBBoxes = pts
                    return pts
                    },
                    anchored:false,
                    vx:0,
                    vy:0,
                    vz:0,
                    elasticity:0.9,
                    weight:100,
                    lcy:0
                }
                shapes.push(newObject)
                return newObject
            }
        }
        class terrainSquare {
            constructor(x,y,z) {
                let newObject = {
                    x,
                    y,
                    z,
                    faces:facesSquare,
                    color:'rgb('+Math.floor(Math.random()*255)+','+Math.floor(Math.random()*255)+','+Math.floor(Math.random()*255)+')',
                    type:0,
                    transparency:1,
                    chunk:chunkCalc(x,z),
                    draw: function(){
                        let i = this
                    var pts = []
                    for(let kv = 0; kv<i.faces.length; kv++){
                        var tpts = []
                        let kt = i.faces[kv]
                    for(let kvv = 0; kvv<kt.length; kvv++){
                            let k = kt[kvv]
                            var p1x = i.x + (terrainDetailHalf * k[0]) 
                            var p1y = i.y + (terrainDetailHalf * k[1]) //- cameraPos.y
                            var p1z = i.z + (terrainDetailHalf * k[2]) //- cameraPos.z
                            var p1 = projectTo3D(p1x, p1y, p1z)
                            tpts.push(p1)
                        }
                        pts.push(tpts.reverse())
                    }
                    i.screenBBoxes = pts
                    return pts
                    },
                    id:Math.random()*1e16,
                    index:shapes.length,
                    screenBBoxes:[],
                    inRiver:false
                }
                shapes.push(newObject)
                return newObject

            }
        }

        class polygon {
            constructor(x,y,z,points) {
                let newObject = {
                    points,
                    color:'rgb('+Math.floor(Math.random()*255)+','+Math.floor(Math.random()*255)+','+Math.floor(Math.random()*255)+')',
                    type:3,
                    transparency:1,
                    x,
                    y,
                    z,
                    draw: function(){
                        let i = this
                    var pts = []
                    for(let kv = 0; kv<i.faces.length; kv++){
                        var tpts = []
                        let kt = i.faces[kv]
                    for(let kvv = 0; kvv<kt.length; kvv++){
                            let k = kt[kvv]
                            var p1x = i.x + (terrainDetailHalf * k[0])
                            var p1y = i.y + (terrainDetailHalf * k[1]) //- cameraPos.y
                            var p1z = i.z + (terrainDetailHalf * k[2]) //- cameraPos.z
                            var p1 = projectTo3D(p1x, p1y, p1z)
                            tpts.push(p1)
                        }
                        pts.push(tpts)
                    }
                    i.screenBBoxes = pts
                    return pts
                    },
                    chunk:chunkCalc(x,z),
                    faces:[[[points[0].x,points[0].y,points[0].z],[points[1].x,points[1].y,points[1].z],[points[2].x,points[2].y,points[2].z],[points[3].x,points[3].y,points[3].z]], //top
                           [[points[4].x,points[4].y,points[4].z],[points[5].x,points[5].y,points[5].z],[points[6].x,points[6].y,points[6].z],[points[7].x,points[7].y,points[7].z]], //bottom
                           [[points[0].x,points[0].y,points[0].z],[points[3].x,points[3].y,points[3].z],[points[7].x,points[7].y,points[7].z],[points[4].x,points[4].y,points[4].z]], //left
                           [[points[1].x,points[1].y,points[1].z],[points[2].x,points[2].y,points[2].z],[points[6].x,points[6].y,points[6].z],[points[5].x,points[5].y,points[5].z]], //right
                           [[points[0].x,points[0].y,points[0].z],[points[1].x,points[1].y,points[1].z],[points[5].x,points[5].y,points[5].z],[points[4].x,points[4].y,points[4].z]], //back
                           [[points[2].x,points[2].y,points[2].z],[points[3].x,points[3].y,points[3].z],[points[7].x,points[7].y,points[7].z],[points[6].x,points[6].y,points[6].z]] //front
                        ],
                    screenBBoxes:[]
                }
                shapes.push(newObject)
                return newObject
            }
        }
        //end object types


        const worldDraw = () => {
            let boundaries = [projectTo3D(0,0,0),projectTo3D(0,-1e4,0),projectTo3D(wwtdh*2,0,whtdh*2),projectTo3D(wwtdh*2,-1e4,whtdh*2),projectTo3D(wwtdh*2,0,0),projectTo3D(wwtdh*2,-1e4,0),projectTo3D(0,0,whtdh*2),projectTo3D(0,-1e4,whtdh*2)]
            let boundaryXMax = Math.max(...boundaries.map(i => i = i.x))
            let boundaryXMin = Math.min(...boundaries.map(i => i = i.x))
            let boundaryYMax = Math.max(...boundaries.map(i => i = i.y))
            let boundaryYMin = Math.min(...boundaries.map(i => i = i.y))
            ctx.clearRect(boundaryXMin-boundaryPanning,boundaryYMin-boundaryPanning,boundaryXMax-boundaryXMin+2*boundaryPanning,boundaryYMax-boundaryYMin+2*boundaryPanning)
            lookArraysUpdate()
            let a = shapes.sort((a,b) => cDist(a) - cDist(b)).reverse()//DEFFO OPTIMIZE THIS
            let lt = 1;
            let lc = 0;
            for(let v = 0; v<a.length; v++){
                let i = a[v]
                let color = i.color
                if(v == 0){
                    ctx.globalAlpha=i.transparency
                    ctx.fillStyle = color
                }
            
                if(i.transparency!=lt){
                    ctx.globalAlpha=i.transparency
                }
                if(color!=lc){
                    ctx.fillStyle = color
                }
                lt = i.transparency
                let points = i.draw()//OPTIMIZE THIS
                let render = true
                if(i.y < cameraPos.y - terrainDetail){
                    render = false
                } else if(i.type == 0 || i.type == 3){
                points.forEach(function(m){
                        m.forEach(function(j,k){
                        if(j.x < -boundaryPanning || j.x > w + boundaryPanning || j.y < -boundaryPanning || j.y > h + boundaryPanning){
                            render = false
                        }
                    })
                })
            } else {
                if(!(i.x>-boundaryPanning && i.x < w + boundaryPanning && i.y > -boundaryPanning && i.y < h + boundaryPanning)){
                        render = false
                    }
            }
            if(i.type == 2){
                render = true
            }
                if(render == true){
                if(i.type == 0 || i.type == 3 || i.type == 2){ 
                    ctx.beginPath()
                    points.forEach(function(face){
                        ctx.moveTo(face[0].x,face[0].y)
                        face.forEach(function(pt){
                            ctx.lineTo(pt.x,pt.y)
                        })
                        ctx.lineTo(face[0].x,face[0].y)
                        ctx.fill()
                    })
                }else if(i.type == 1){
                    let centerPoint = projectTo3D(i.x,i.y,i.z)
                    ctx.beginPath()
                    ctx.arc(centerPoint.x,centerPoint.y,points,0,360)
                    ctx.fill()
                    ctx.stroke()
                }
            }
            }
        }
        setInterval(function(){
            if(keysdown.includes('ArrowLeft')){
                cameraPos.rx+=-5
            }
            if(keysdown.includes('ArrowRight')){
                cameraPos.rx+=5
            }
            if(keysdown.includes('w')){
                cameraPos.z += 30
            }
            if(keysdown.includes('s')){
                cameraPos.z += -30

            }
            if(keysdown.includes('a')){
                cameraPos.x+=-30
            }
            if(keysdown.includes('d')){
                cameraPos.x+=30
            }
            if(keysdown.includes('e')){
                cameraPos.y+=-17
            }
            if(keysdown.includes('q')){
                cameraPos.y+=17
            }
            if(keysdown.includes('j')){
                let targetShape = shapeFromPoint(mx,my)
                targetShape.color = '#FF0000'
            }
            worldDraw()
        },75)
       
        //WORLD GEN        
        function regenWorld(){
        for(let i = 0; i< worldHeight; i++){
            riverDips.push({x:i*riverSlope+y1+Math.sin(i/3),y:i})
        }
        for(let x = 0; x<worldWidth; x++){
            for(let y = 0; y<worldHeight; y++){
                let targetY = 0;
                let shapeInRiver = false
                for(let v = 0; v<heightMounds.length; v++){
                    let i = heightMounds[v]
                    targetY+=-terrainDetail/(2**((x-i.x)**2 + (y-i.y)**2 + 1))
                }
                riverDips.forEach(function(i,v){
                    let c = terrainDetail*riverDepth*Math.sqrt(1-1/riverWidth*(x-i.x)**2 - 1/riverWidth*(y-i.y)**2)
                    if(!isNaN(c)){
                        targetY+=c
                        shapeInRiver = true
                    }
                })
                targetY*=2/(worldWidth-x+1)
                let a = new terrainSquare(x*terrainDetail,targetY,y*terrainDetail)
                if(shapeInRiver == false){
                    shapes[a.index].color = 'rgb(50,205,50)'//'rgb('+(50+Math.floor(Math.random()-0.5)*10)+','+(205+Math.floor(Math.random()-0.5)*10)+','+(50+Math.floor(Math.random()-0.5)*10)+')'
                } else {
                    shapes[a.index].color = 'rgb(222,213,187)'
                }
                baseShapes.push({id:a.id,x:x,y:y})
                heightMap[y*worldHeight+x] = targetY
                
            }
        }
        shapes.forEach(function(i,v){
            if(i.type == 0){
                let b = new terrainSquare(i.x,i.y + terrainDetailHalf, i.z)
                let bh = (-i.y)*2/terrainDetail + 0.5
                if(i.y < 0){
                    shapes[b.index].color = 'rgb(128,128,128)'
                } else {
                    bh+=-1
                    shapes[b.index].color = 'rgb(0,0,255)'
                }
                shapes[b.index].faces = 
                [[[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]],
                [[-1, -1, 1], [1, -1, 1], [1, bh*1, 1], [-1, bh*1, 1]],
                [[-1, -1, -1], [1, -1, -1], [1, bh*1, -1], [-1, bh*1, -1]],
                [[-1, -1, 1], [-1, -1, -1], [-1, bh*1, -1], [-1, bh*1, 1]],
                [[1, -1, 1], [1, -1, -1], [1, bh*1, -1], [1, bh*1, 1]],
                [[-1, bh*1, 1], [1, bh*1, 1], [1, bh*1, -1], [-1, bh*1, -1]]]
            }
            setTimeout(function(){
                let c = -terrainAtPoint(i.x,i.z)
                //i.color = 'rgb('+c+','+c+','+c+')'
            },500)
        })  
    }
    regenWorld()
        //end world gen
    

        //PHYSICS
        let physics = true
        if(physics == true){
        setInterval(function(){
            for(let v = 0; v<shapes.length; v++){
                let i = shapes[v]
                if(i.anchored == false){
                //LIMIT CHUNK RENDER DISTANCE W/ CHUNK DISTANCE MAP TO OPTIMIZE
                if(i.type == 2){
                    i.x+=i.vx;
                    i.y+=i.vy;
                    i.z+=i.vz;
                    let mappedCell = (i.x/terrainDetail) >> 0 + ',' + (i.z/terrainDetail) >> 0
                    let chunk = shapes.filter(j => j.chunk == i.chunk)
                    for(let vc = 0; vc<15; vc++){
                        let ic = chunk[vc]
                        let mbx = Math.abs(i.x - ic.x)
                        let mby = Math.abs(i.y - ic.y)
                        let mbz = Math.abs(i.z - ic.z)
                        let dirs = [mbx,mby,mbz]
                        let colliding = (mbx < terrainDetail && mby < terrainDetail && mbz < terrainDetail)
                        if(colliding && i.y < ic.y){
                            i.vx*=-1
                            i.vy*=-1
                            i.vz*=-1
                            i.y+=mbz+-i.vy-terrainDetailHalf
                        }
                    }
                        if(0.1*(i.y - i.lcy) >> 0 != 0){
                        i.vy += 2
                        }
                        let elast = i.elasticity
                        i.vx *= elast
                        i.vy *= elast*airDrag
                        i.vz *= elast
                }
            }
            }
        },50)
    }
    
        //end physics


        let a = new Cube(0,-terrainDetail,0,100,100,100)
        let b = new Cube(0,-3*terrainDetail,0,100,100,100)

        //new Cube(wwtdh/2 + terrainDetail,-100,whtdh/2,100,100,100)
       // new polygon(0,-100,0,[{x:-1,y:1,z:1},{x:1,y:5,z:1},{x:1,y:1,z:-4},{x:-1,y:1,z:-1},{x:-1,y:-1,z:1},{x:1,y:-1,z:1},{x:1,y:-1,z:-1},{x:-1,y:-1,z:-1}])
    </script>
</body>
</html>